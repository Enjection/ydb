#include <ydb/core/tx/schemeshard/ut_helpers/helpers.h>
#include <ydb/core/tx/schemeshard/ut_helpers/test_with_reboots.h>
#include <ydb/core/tx/schemeshard/schemeshard.h>
#include <ydb/core/tx/schemeshard/schemeshard_impl.h>

using namespace NKikimr;
using namespace NSchemeShard;
using namespace NSchemeShardUT_Private;

namespace {

TVector<TEvSchemeShard::TEvInternalReadNotificationLogResult::TEntry> ReadNotificationLog(
    TTestActorRuntime& runtime)
{
    auto sender = runtime.AllocateEdgeActor();
    ForwardToTablet(runtime, TTestTxConfig::SchemeShard, sender,
        new TEvSchemeShard::TEvInternalReadNotificationLog());
    TAutoPtr<IEventHandle> handle;
    auto event = runtime.GrabEdgeEvent<TEvSchemeShard::TEvInternalReadNotificationLogResult>(handle);
    UNIT_ASSERT(event);
    return event->Entries;
}

} // anonymous namespace

Y_UNIT_TEST_SUITE(TNotificationLogReboots) {

    Y_UNIT_TEST_WITH_REBOOTS(CreateTableWithReboots) {
        t.Run([&](TTestActorRuntime& runtime, bool& activeZone) {
            {
                TInactiveZone inactive(activeZone);
            }

            t.TestEnv->ReliablePropose(runtime, CreateTableRequest(++t.TxId, "/MyRoot",
                "Name: \"Table1\""
                "Columns { Name: \"key\"   Type: \"Uint64\" }"
                "Columns { Name: \"value\" Type: \"Utf8\" }"
                "KeyColumnNames: [\"key\"]"),
                {NKikimrScheme::StatusAccepted, NKikimrScheme::StatusAlreadyExists,
                 NKikimrScheme::StatusMultipleModifications});
            t.TestEnv->TestWaitNotification(runtime, t.TxId);

            {
                TInactiveZone inactive(activeZone);
                TestDescribeResult(DescribePath(runtime, "/MyRoot/Table1"),
                    {NLs::Finished, NLs::IsTable});

                auto entries = ReadNotificationLog(runtime);
                bool found = false;
                for (const auto& e : entries) {
                    if (e.PathName == "Table1") {
                        found = true;
                        UNIT_ASSERT(e.SequenceId > 0);
                        UNIT_ASSERT_VALUES_EQUAL(e.ObjectType, (ui32)NKikimrSchemeOp::EPathTypeTable);
                        break;
                    }
                }
                UNIT_ASSERT_C(found, "Notification log entry for Table1 not found");
            }
        });
    }

    Y_UNIT_TEST_WITH_REBOOTS(MultipleCreateTablesWithReboots) {
        t.Run([&](TTestActorRuntime& runtime, bool& activeZone) {
            {
                TInactiveZone inactive(activeZone);
                t.TestEnv->ReliablePropose(runtime, CreateTableRequest(++t.TxId, "/MyRoot",
                    "Name: \"T1\""
                    "Columns { Name: \"key\" Type: \"Uint64\" }"
                    "KeyColumnNames: [\"key\"]"),
                    {NKikimrScheme::StatusAccepted, NKikimrScheme::StatusAlreadyExists,
                     NKikimrScheme::StatusMultipleModifications});
                t.TestEnv->TestWaitNotification(runtime, t.TxId);
            }

            t.TestEnv->ReliablePropose(runtime, CreateTableRequest(++t.TxId, "/MyRoot",
                "Name: \"T2\""
                "Columns { Name: \"key\" Type: \"Uint64\" }"
                "KeyColumnNames: [\"key\"]"),
                {NKikimrScheme::StatusAccepted, NKikimrScheme::StatusAlreadyExists,
                 NKikimrScheme::StatusMultipleModifications});
            t.TestEnv->TestWaitNotification(runtime, t.TxId);

            {
                TInactiveZone inactive(activeZone);
                TestDescribeResult(DescribePath(runtime, "/MyRoot/T1"),
                    {NLs::Finished, NLs::IsTable});
                TestDescribeResult(DescribePath(runtime, "/MyRoot/T2"),
                    {NLs::Finished, NLs::IsTable});

                auto entries = ReadNotificationLog(runtime);

                // T1 was created in inactive zone — its entry must exist
                bool foundT1 = false;
                for (const auto& e : entries) {
                    if (e.PathName == "T1") {
                        foundT1 = true;
                        UNIT_ASSERT(e.SequenceId > 0);
                    }
                }
                UNIT_ASSERT_C(foundT1, "Notification log entry for T1 not found");

                // Verify monotonic sequence IDs across all entries
                for (size_t i = 1; i < entries.size(); ++i) {
                    UNIT_ASSERT_C(entries[i].SequenceId > entries[i-1].SequenceId,
                        "SequenceIds must be strictly monotonic");
                }
            }
        });
    }

    Y_UNIT_TEST_WITH_REBOOTS(AlterTableWithReboots) {
        t.Run([&](TTestActorRuntime& runtime, bool& activeZone) {
            {
                TInactiveZone inactive(activeZone);
                t.TestEnv->ReliablePropose(runtime, CreateTableRequest(++t.TxId, "/MyRoot",
                    "Name: \"Table1\""
                    "Columns { Name: \"key\"   Type: \"Uint64\" }"
                    "Columns { Name: \"value\" Type: \"Utf8\" }"
                    "KeyColumnNames: [\"key\"]"),
                    {NKikimrScheme::StatusAccepted, NKikimrScheme::StatusAlreadyExists,
                     NKikimrScheme::StatusMultipleModifications});
                t.TestEnv->TestWaitNotification(runtime, t.TxId);
            }

            TestAlterTable(runtime, ++t.TxId, "/MyRoot", R"(
                Name: "Table1"
                Columns { Name: "extra" Type: "Uint32" }
            )");
            t.TestEnv->TestWaitNotification(runtime, t.TxId);

            {
                TInactiveZone inactive(activeZone);
                TestDescribeResult(DescribePath(runtime, "/MyRoot/Table1"),
                    {NLs::Finished, NLs::IsTable,
                     NLs::CheckColumns("Table1", {"key", "value", "extra"}, {}, {"key"})});

                auto entries = ReadNotificationLog(runtime);

                // CREATE was done in inactive zone — its entry must exist
                bool foundCreate = false;
                for (const auto& e : entries) {
                    if (e.PathName == "Table1" && e.OperationType == (ui32)TTxState::TxCreateTable) {
                        foundCreate = true;
                        UNIT_ASSERT(e.SequenceId > 0);
                    }
                }
                UNIT_ASSERT_C(foundCreate, "CREATE TABLE entry not found in notification log");

                // Verify monotonic sequence IDs across all entries
                for (size_t i = 1; i < entries.size(); ++i) {
                    UNIT_ASSERT_C(entries[i].SequenceId > entries[i-1].SequenceId,
                        "SequenceIds must be strictly monotonic");
                }
            }
        });
    }

    // Verify that the NextNotificationSequenceId counter is properly restored
    // after reboots: new operations must get strictly higher sequence IDs than
    // operations that completed before the reboot point.
    Y_UNIT_TEST_WITH_REBOOTS(SequenceIdCounterSurvivesReboot) {
        t.Run([&](TTestActorRuntime& runtime, bool& activeZone) {
            {
                TInactiveZone inactive(activeZone);
                t.TestEnv->ReliablePropose(runtime, CreateTableRequest(++t.TxId, "/MyRoot",
                    "Name: \"T1\""
                    "Columns { Name: \"key\" Type: \"Uint64\" }"
                    "KeyColumnNames: [\"key\"]"),
                    {NKikimrScheme::StatusAccepted, NKikimrScheme::StatusAlreadyExists,
                     NKikimrScheme::StatusMultipleModifications});
                t.TestEnv->TestWaitNotification(runtime, t.TxId);
            }

            // Create T2 in active zone — reboots injected here.
            t.TestEnv->ReliablePropose(runtime, CreateTableRequest(++t.TxId, "/MyRoot",
                "Name: \"T2\""
                "Columns { Name: \"key\" Type: \"Uint64\" }"
                "KeyColumnNames: [\"key\"]"),
                {NKikimrScheme::StatusAccepted, NKikimrScheme::StatusAlreadyExists,
                 NKikimrScheme::StatusMultipleModifications});
            t.TestEnv->TestWaitNotification(runtime, t.TxId);

            {
                TInactiveZone inactive(activeZone);
                TestDescribeResult(DescribePath(runtime, "/MyRoot/T1"),
                    {NLs::Finished, NLs::IsTable});
                TestDescribeResult(DescribePath(runtime, "/MyRoot/T2"),
                    {NLs::Finished, NLs::IsTable});

                auto entries = ReadNotificationLog(runtime);

                // T1 was created in inactive zone — its entry must exist
                ui64 t1SeqId = 0;
                for (const auto& e : entries) {
                    if (e.PathName == "T1") t1SeqId = e.SequenceId;
                }
                UNIT_ASSERT_C(t1SeqId > 0, "T1 entry not found in notification log");

                // If T2's entry exists, verify counter continuity
                for (const auto& e : entries) {
                    if (e.PathName == "T2") {
                        UNIT_ASSERT_C(e.SequenceId > t1SeqId,
                            "T2 SequenceId (" << e.SequenceId
                                << ") must be greater than T1 SequenceId (" << t1SeqId << ")");
                    }
                }

                // Verify monotonic sequence IDs across all entries
                for (size_t i = 1; i < entries.size(); ++i) {
                    UNIT_ASSERT_C(entries[i].SequenceId > entries[i-1].SequenceId,
                        "SequenceIds must be strictly monotonic");
                }
            }
        });
    }
}
